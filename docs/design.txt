
attack opportunities analyzed as a funnel

Intuitively, each particular behaviour of a BitSmuggler connection
narrows down the investigation space for a network censor.

Such signs could be.
eg:
 * it only uses uTorrent 
 * if all files are exchanged within swarm of size 2, with a single connection
to the other peer in the swarm it means that an adversary maybe can count
connections for the same infohash (pattermatch for the bittorrent header)
and narrow down to all bitTorrent connections that use a single other
peer to get thier file data

Some signs are are easier to check or are a strong give away (the presence of
a particular constant string in the data being exchanged is almost certain
immediate give away.)

Some cannot be checked at wire speed but may be checked on a slow path.
(eg. is the file really a video file as it claims to be? or is it just a blob
of encrypted data?)

=== File exchanges ===

Methods:

1. setup a file exchange in a swarm of size 2 leechers with a custom file
   (the server and the client)

pros:
  * no outside interference
    (new leechers/seeders can at most slow down things a bit)
  * large throughput
  * simplest to implement

2. join existing real swarm in which the server is present
cons:
  * can't express preference for a certain peer with popular torrents such as utorrrent on 
linux. unlikely to be added soon
( http://forum.utorrent.com/topic/91746-adding-peers-manually/ ).
therefore getting the client to connect to the right peer in a large swarm is purely 
based on luck.  retries are a no-go (cutting formed connections to force an eventual

even if functionality existed, all bittorrent clients attempt to make connections 
to other peers in the swarm or receive connections to other peers in the swarm,
therefore you will naturally end up with many connections if you are in a big swarm

  connection to the "right" peer is a big giveaway if repeated a couple of times)
  * based on above, only small swarms can be joined reducing this to solution no. 1
  * how do you do steganography? prefetching the file by a client is slow


3. have 2 machines on the receiving side - one is seeding. 1 is leeching.

how is initial contact made? leeching is a pro-active action on the side of the receiver
if you cannot put any data in the seeding 


=== Bootstrap ===

knowing only the IP of the bridge requires you do some sort reverse IP lookup
to know what torrents to ask for or some way of asking the peer what torrents 
he's seeding.

idea 1
use a bootstrap steganographied file. fetch a file which informs you about 
which torrent to look for in data. the infohash of this file is provided in the 
bridge descriptor. the file uses steganography to put encrypted data (with a shared
secret put in the bridge descriptor - so it's not really a secret it's just meant
to give you random looking data - once the tor descriptor is leaked - undetectability
goes away. only privacy remains)

However, the infohash of the file will be broken. since changing the contents of it
involves making a hash collision to make the infohash match.

!! give away. you always fetch a seeded file (the bigger it is the slower the boot) 
 and then you fetch another file in a p2p fashion

idea 2
use a unique file for all incoming peers. this sucks. they all clobber on the same file
and join the same swarm.

What if there is the same bridge behind many machines? it's still the same shit, 
you need 1 machine per 3 connections. that's very poor scaling.

idea 3
make a bootstrap file with a large set of seeded infohashes and peers connecting
select 1 at random to minimize collisions.


=== real infohash attack on solution 1 === 

compile a database of all infohashes, and red flag connections that have 
infohashes not part of that database. not a great attack, probably a lot of
false positives, since new hashes are created all the time


=== Information leaks ===

reverse proxying DHT leak - UNCONFIRMED

when reverse proxied the peer connection comes from localhost.

does this info end up leaking outside? because if it does it's a sure
sign that bitSmuggler is being used.

This is most likely not a problem. suppose the DHT logic may attempt to make
 note of a new swarm member based on an incoming connection. the IP is
 solveable but it does not know, which is the port the peer coming in is 
listening on.

This is verifiable, but most likely a peer record ends up in the DHT only if 
someone advertises it, and usually the peer always advertises itself - aka i 
don't think the receiver will say "here's another peer that i know of" to 
the DHT.


