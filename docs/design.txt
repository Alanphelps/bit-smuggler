
attack opportunities analyzed as a funnel

Intuitively, each particular behaviour of a BitSmuggler connection
narrows down the investigation space for a network censor.

Such signs could be.
eg:
 * it only uses uTorrent 
 * if all files are exchanged within swarm of size 2, with a single connection
to the other peer in the swarm it means that an adversary maybe can count
connections for the same infohash (pattermatch for the bittorrent header)
and narrow down to all bitTorrent connections that use a single other
peer to get thier file data

Some signs are are easier to check or are a strong give away (the presence of
a particular constant string in the data being exchanged is almost certain
immediate give away.)

Some cannot be checked at wire speed but may be checked on a slow path.
(eg. is the file really a video file as it claims to be? or is it just a blob
of encrypted data?)


=== slow path analysis vs wire analysis ===

An adversary may do 2 kinds of analysis

* real-time (wire analysis)
  - with then intention of catching connections as they happen;
* slow path (take connections) 
    - simple strategy - capture and store bittorrent traffic for a day;
      take your time to analyze the capture and detect all suspicious
      connections. this yields bridge addresses, and addresses of people connected
      to them, but from the past
    - filter a small part of connections in real-time and analyze them on a slowpath
      while they may still be running

WARNING:
current design is defeatable by slow path analysis if the censor gets hold of
the torrent file. to send arbitrary data through the bittorrent connection
one needs to break the hashes of the pieces. 

In nature hash checks don't fail that often in a single connection. So it's a 
strong sign that it is a rogue connection.

This part of the protocol allows you to fetch the torrent file from peers.
http://www.bittorrent.org/beps/bep_0009.html

according to this paper, dht is reasonable to crawl (8000 nodes in 2 hrs rate
- your rate shuold scale with number of machines)
https://www.usenix.org/legacy/event/woot10/tech/full_papers/Wolchok.pdf
Thus you can obtain torrent files.

=== File exchanges ===

Methods:

1. setup a file exchange in a swarm of size 2 leechers with a custom file
   (the server and the client)

pros:
  * no outside interference
    (new leechers/seeders can at most slow down things a bit)
  * large throughput
  * simplest to implement

cons: 
  * it's a small swarm all the time (size 2, peer, peer) - sign

2. join existing real swarm in which the server is present
cons:
  * can't express preference for a certain peer with popular torrents such as utorrrent on 
linux. unlikely to be added soon
( http://forum.utorrent.com/topic/91746-adding-peers-manually/ ).
therefore getting the client to connect to the right peer in a large swarm is purely 
based on luck.  retries are a no-go (cutting formed connections to force an eventual

even if functionality existed, all bittorrent clients attempt to make connections 
to other peers in the swarm or receive connections to other peers in the swarm,
therefore you will naturally end up with many connections if you are in a big swarm

  connection to the "right" peer is a big giveaway if repeated a couple of times)
  * based on above, only small swarms can be joined reducing this to solution no. 1
  * how do you do steganography? prefetching the file by a client is slow

3. have 2 machines on the receiving side - one is seeding. 1 is leeching.

how is initial contact made? leeching is a pro-active action on the side of the receiver
This option is quite problematic and does not provide a clear advantage.

cons:
  recriprocal seeding is a give-away. unlikely to happen often in nature


=== Bootstrap ===

knowing only the IP of the bridge requires you do some sort reverse IP lookup
to know what torrents to ask for or some way of asking the peer what torrents 
he's seeding.

idea 1
use a bootstrap steganographied file. fetch a file which informs you about 
which torrent to look for in data. the infohash of this file is provided in the 
bridge descriptor. the file uses steganography to put encrypted data (with a shared
secret put in the bridge descriptor - so it's not really a secret it's just meant
to give you random looking data - once the tor descriptor is leaked - undetectability
goes away. only privacy remains)

However, the infohash of the file will be broken. since changing the contents of it
involves making a hash collision to make the infohash match.

!! give away. you always fetch a seeded file (the bigger it is the slower the boot) 
 and then you fetch another file in a p2p fashion

idea 2
use a unique file for all incoming peers. this sucks. they all clobber on the same file
and join the same swarm.

What if there is the same bridge behind many machines? it's still the same shit, 
you need 1 machine per 3 connections. that's very poor scaling.

idea 3
make a bootstrap file with a large set of seeded infohashes and peers connecting
select 1 at random to minimize collisions.

eg. put 100 seeded files. the server will be seeding all of them.
a connecting client picks 1 at random and joins the swarm.

Steganography:
  * primitive - encrypted blobs - placed instead of file data
  * shaped as a viewable video file
     research stego optiions for video
  * encrypted blobs placed inside video containers and displacing codecs

* Video steganography *
http://en.wikipedia.org/wiki/Steganography_tools
OpenPuff  - windows only
Steganosaurus
-- none of them look great atm...

Video steganography is a hard problem and uncessary to solve now. given that
the file is broken anyway there's no point in making a viewable video when
streaming. therefore maybe wrapping something in a video format is enough


=== File used ===

1. fake file.
  randomly generated
2.
real file.

=== Information leaks ===

reverse proxying DHT leak - UNCONFIRMED

when reverse proxied the peer connection comes from localhost.

does this info end up leaking outside? because if it does it's a sure
sign that bitSmuggler is being used.

This is most likely not a problem. suppose the DHT logic may attempt to make
 note of a new swarm member based on an incoming connection. the IP is
 solveable but it does not know, which is the port the peer coming in is 
listening on.

This is verifiable, but most likely a peer record ends up in the DHT only if 
someone advertises it, and usually the peer always advertises itself - aka i 
don't think the receiver will say "here's another peer that i know of" to 
the DHT.

=== Current design ===

File exchange: solution 1 - swarm size 2
 
  

