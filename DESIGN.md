
## BitTorrent cover

The design of how to hide behind bittorrent was created with the following goal in mind:
make it look as genuine as possible in order to blend in with all other bittorrent
connections.

Bit-smuggler never makes any network connections by itself. All connections
between a bit-smuggler client and server are tunneled through connections
created by the bittorrent clients living on both sides.

Both the client and server each run exactly one instance of a bittorrent client.

The server runs a bittorrent client that presents itself as a peer holding a 
set of of incomplete files (contact-files). 

The client knows the server descriptor:

```haskell
data ServerDescriptor = ServerDescriptor {
    serverAddr :: IP 
  , contactFiles :: [ContactFile]
  , serverPubKey :: Key
}
```

The  bit-smuggler's client bittorrent client holds incomplete copies of the contact files as well.
The incomplete copies of a contact file F owned by both the client and the server
are not the same so that it allows the 2 peers to exchange pieces back-and-forth.
(each peer needs some pieces that the other has and has some pieces that the other doesn't)

The bit-smuggler client picks at random a contact file to download and instructs its
bittorrent client to go for it. the bittorrent client will eventually connect to its
peer (the bitsmuggler server) and a bitsmuggler connection can be established using that
data exchange as a tunnel. 

When the file being exchanged is exhausted (no more data flows back and forth
- all data that could be exchanged was exchanged),
the client requests to download another contact file at random.

The server constantly replenishes its exhausted contact files. it polls its bittorrent
client to see what files are exhausted. If it finds an exhaust it file, it deletes it
and readds it later, partially completed. so it can be reused for another
bit-smuggler session.

### Contact files

Contact files are currently random data files of various lengths generated with
a pseudorandom-generator from a single integer seed. 
both client and server generate these files ahead of time knowing the integer seed and the length, before establishing a connection.


They can be real files but that involes pulling the data of the respective file
(eg. Pirates of the Carribean) ahead of time.

This is considered good enough since, as discussed in the README.md, it doesn't make it
easier to detect in real-time and bit-smuggler will be detected anyway on a slow path.

File names are manually created but can be random generated perhaps using 
markov chains (further work).

Partial copies are generated by randomly selecting pieceCount / 2 pieces and zeroing them
out (removing the data). This means that each peer will get from the other roughly
1/4 of a file. So to exhaust a 4GB file, roughly 1GB will flow in both directions.

The server descriptor's metadata for each file consists of its torrent file and its integer seed. Currently the torrent file is distributed in its entirety but if you strip out the
piece hash data, a file's metadata will be down to 100 bytes (order of magnitude). For a server that holds 100 contact files is 10Kb order of size for a server descriptor. The question is open if this is acceptable or not.

### bit-smuggler session and disconnects

Since we want a long lived connection whose duration is independent of the duration of
downloading the files, we have the concept of a bit-smuggler session that can span over
multiple bittorrent file downloads.

Upon the first accept of a connection by the client, the server presents it with 
a *session token* (a cookie of sorts) that the client needs to use when 
disconnects happen to recover it's old session.

Suppose a bittorrent file is exhausted and the clients disconnect. The bit-smuggler
client commands its bittorrent client to pull another file from its peer (the server)
and when this reconnection happens it presents the session token in the handshake.
Based on it, the server pulls out the old session and starts streaming data normally.

The server keeps a session active around for a certain amount of time.

## Crypto

We are using symmetric key cryptography.

We are *assuming* the client **knows** the  public key of the server and sends 
its own  public key in plain but transformed so it looks like a random string
with djb's [elligator](http://cr.yp.to/elligator/elligator-20130527.pdf)

then they both derive a shared secret and use that to encrypt the rest of the 
communication. (see the crypto code and a diagram [here](https://github.com/danoctavian/bit-smuggler/blob/master/BitSmuggler/src/Network/BitSmuggler/Crypto.hs) )


## System architecture

BitSmuggler consists of a client and a server. Both the client and the server run a bittorrent instance and capture its traffic using socks (for outgoing connections) and a 
reverse proxy (for incoming connections). 

The Bitsmuggler process orchestrates the whole thing sending commands to the bittorrent clients and having hooks to read/write the tcp streams passing through the sockets.

See [diagram](https://github.com/danoctavian/bit-smuggler/blob/master/docs/system-components.jpg) for a visual representation of the components of the system.
The reverse proxy works by setting IPTABLES rules to redirect all traffic aimed at the
bittorrent port to the port of the proxy, which will then redirect itself to the bittorrent
client.

```bash
# this sends all traffic aimedat 6881 to the proxy listening locally on 4001
sudo iptables -t nat -A PREROUTING -p tcp --dport 6881 -j DNAT --to 127.0.0.1:4001
```


## Protocols

The client and server talk by storing data in the data section of [BitTorrent piece messages](https://wiki.theory.org/BitTorrentSpecification#piece:_.3Clen.3D0009.2BX.3E.3Cid.3D7.3E.3Cindex.3E.3Cbegin.3E.3Cblock.3E)

Therefore, the channel for the bit-smuggler protocols is packet-based, with the 
reliability properties of TCP.

The reliability properties can be broken by an adversary that can tamper with the 
application level protocol.

*Example attack*: he can flip a bit in a bit-smuggler piece message,
which may contain a bit-smuggler message - thus breaking the cipher-text which
cannot be decrypted once it reaches the other side and the packet is lost.

The bit-smuggler protocol stack starting from the bottom:

* **TCP**

* **BitTorrent**

* **encryption** = not a protocol but the encryption operation is applied over the whole data block stored in a bittorrent file piece

* **bit-smuggler ARQ** = a low overhead Automatic repeat request protocol that operates on packets embedded in piece messages ensuring reliable delivery. The reasons to include this in the stack are debatable:

    1. It protects against an adversary performing tampering attacks as described above. This is questionable since if the adversary can tamper at application level he may be able to do an analysis that detects bit-smuggler in real-time
    2. the implementation easily deals with disconnect events implicitly (switching from 1 file to another means 1 packet may be lost in flight). this can be achieved with a less complicated logic
    3. it's low overhead (small headers, rarely resends, sticks ack numbers on top of normal data packets to minimize the number of piece packets used)

* **bit-smuggler Wire** - length prefixed messages

* **bit-smuggler data-control** - 2 types of messages - data and control. control takes
precendence in the send queue over data. control are handshakes accepts and any other
potential instructions added later on (eg. server tell client to switch swarm)

* **application** - the user is provided with same connection interface given by TCP
 (a stream of data) and can build any application-level protocol on top of that.

## Threat model

The adversary (censor) has the following attributes:

* is a state-level authority

* has an interest in connecting to the Internet and allowing the individuals sub-
jected to censorship to connect to parts of the Internet for the socio-economical
advantages it provides. It is thus interested in avoiding over-blocking
• the state-level adversary has control over a section of the global network which we
will call the national network delimited by its national borders. We shall call this
delimiting perimiter its network perimeter.

* has full active and passive control over the national network. The censor can
passively monitor all traffic entering and leaving its networks. It is possible for the
censor to actively tamper with traffic by injecting, modifying or dropping it or just
hjacking TCP sessions

* performs Internet traffic filtering at the network perimeter based on: address filters,
content pattern filters, statistical filters; uses Deep-packet-inspection (DPI) to look
at the contents of the packets

* can be suspicious of encrypted network connections (ssh, vpn protocol, https, Bit-
Torrent encryption, tls) and may choose to block them without a strong justifica-
tion

The adversary’s objectives are:

* block access to certain Internet resources

* monitor all Internet usage
  - know which parties are communicating

  - know the content/type of their communication

The adversary’s *assumed* limitations are:

* DPI real-time analysis has strong time limitations for the computations that can be
performed while on-the-side anlysis forces the censor to select a very small portion
of the traffic for more complex analysis

* does not have access to the censored users’ machines. Alhough the censor may issue
mandates to inspect user devices or infect user devices with surveillance software,
BitSmuggler cannot service the user reliably if his/her machine is compromised

* has very limited abilities outside its network. It does not control any external
network infrastructure or any popular external websites.

* is subjected to economical constraints - improving its surveillance infrastructure
to counter new circumvention methods takes time and money

* has strong socio-economic reasons not to block BitTorrent traffic

* should Tor be the proxy, it does not own enough malicious Tor relays to allow it to land attacks which compromise Tor’s unlinkability







